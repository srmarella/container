// devcontainer.json (JSONC)
// This file is intentionally verbose to serve as living documentation for daily Python development.
{
  // ---------------------------------------------------------------------------
  // Human-friendly label shown in: VS Code window title, Remote Explorer list, command palette container pickers,
  // Codespaces dashboard (if used), and devcontainer CLI listings (does NOT set Docker containerName unless you add that separately).
  // ---------------------------------------------------------------------------
  "name": "python-daily-dev",
  // NOTE: The Dev Containers spec does not currently support a top-level "containerName" property.
  // To have a stable Docker container name, inject it via runArgs (see runArgs section below where we add --name).

  "build": {
    "dockerfile": "Dockerfile",
    "context": ".." // Use workspace root as Docker build context so Dockerfile can COPY requirements.txt
    // All tunable build arguments (PYTHON_VERSION, PYTHON_ENV, PYTHON_SHA256, etc.) are now
    // centralized in the Dockerfile with sensible defaults. Override them at build time via:
    //   devcontainer build --build-arg PYTHON_ENV=alt_env --build-arg PYTHON_VERSION=3.x.y
    // Keeping args out of this file avoids duplication and drift.
  },

  // ---------------------------------------------------------------------------
  // Features: add reusable components (git, GitHub CLI, Node for tooling, etc.)
  // Will work best when base image is a devcontainers image (our Dockerfile uses one now).
  // Docs: https://github.com/devcontainers/features
  // ---------------------------------------------------------------------------
  "features": {
    "ghcr.io/devcontainers/features/git:1": {},
    "ghcr.io/devcontainers/features/github-cli:1": {}
  },

  // ---------------------------------------------------------------------------
  // User: How VS Code determines which user to run as in the container:
  // 1. VS Code checks devcontainer.json for "remoteUser" property (we don't set this)
  // 2. If not found, VS Code uses the container's default user (set by Dockerfile's USER directive)
  // 3. Our Dockerfile ends with: USER vscode
  // 4. Therefore, VS Code server runs as the 'vscode' user automatically
  //
  // This approach avoids duplication - the user is defined once in Dockerfile.
  // If you need to temporarily run VS Code server as root (e.g., for diagnosing
  // permission issues), you can reintroduce: "remoteUser": "root"
  // Or override by adding a devcontainer feature that switches users post-build.
  // ---------------------------------------------------------------------------

  // ---------------------------------------------------------------------------
  // VS Code specific customizations: settings + extensions.
  // You can alternatively use top-level "extensions": [...] but this nested form
  // supports other IDEs implementing the spec without inheriting VS Code specifics.
  // ---------------------------------------------------------------------------
  "customizations": {
    "vscode": {
      "settings": {
        // Set Python interpreter dynamically based on PYTHON_ENV environment variable.
        // How it works:
        // 1. Dockerfile defines: ARG PYTHON_ENV=my_python_dev (build-time variable)
        // 2. Dockerfile sets: ENV PYTHON_ENV=${PYTHON_ENV} (runtime environment variable)
        // 3. VS Code resolves ${containerEnv:PYTHON_ENV} to the actual value from the container's environment
        // 4. Final path becomes: /opt/my_python_dev/bin/python3
        // To change: update only the ARG PYTHON_ENV value in Dockerfile and rebuild container
        "python.defaultInterpreterPath": "/opt/${containerEnv:PYTHON_ENV}/bin/python3",

        // --- SNOWFLAKE EXTENSION SETUP ---
        // The following ensures the Snowflake VS Code extension is installed and configured for remote containers:
        // 1. The extension is listed in "extensions" below, so it will be auto-installed in the container.
        // 2. The connection path is set to ~/.snowflake/connections.toml (copied or mounted by postCreate.sh logic).
        // 3. If the extension does not appear:
        //    - Open a .sql file or the Snowflake sidebar to trigger activation.
        //    - Check the Extensions sidebar (should show "Snowflake" as enabled in the container).
        //    - If missing, rebuild the container or install manually from the Extensions view.
        //    - Check the Output panel for errors under "Snowflake" or "Extensions".
        //    - Confirm that ~/.snowflake/connections.toml exists and is readable.
        // 4. The extension will use the config at the path below:
        "snowflake.connectionsConfigFile": "${containerEnv:HOME}/.snowflake/connections.toml"
          },
          "extensions": [
            "snowflake.snowflake-vsc"
          ]
      }
  },


  // ---------------------------------------------------------------------------
  // Lifecycle commands:
  // postCreateCommand: runs once when container is first created.
  // postStartCommand: runs each start (keep fast)
  // postAttachCommand: runs when VS Code attaches.
  // ---------------------------------------------------------------------------
  // updateContentCommand removed earlier (now documented in README). Keeping only needed lifecycle hooks.
  // ---------------------------------------------------------------------------
  // ---------------------------------------------------------------------------
  // Mounts: Optional host dotfiles (Snowflake config, SSH keys, Git config)
  //
  // How localEnv works:
  // - ${localEnv:VARIABLE} reads environment variables from your HOST system (not container)
  // - Resolves at container creation time to actual paths
  // - Cross-platform: different variables exist on different operating systems
  //
  // Windows host: ${localEnv:USERPROFILE} = "C:\Users\srikanth.marella"
  // macOS host:   ${localEnv:HOME} = "/Users/srikanth"
  // Linux host:   ${localEnv:HOME} = "/home/srikanth"
  //
  // Strategy: Combine ${localEnv:HOME} and ${localEnv:USERPROFILE} so whichever exists becomes the prefix
  // Result: Host directories appear inside the container at /host-snowflake, /root/.ssh, and /root/.gitconfig
  // ---------------------------------------------------------------------------
  "mounts": [
    // Mount Snowflake config (macOS / Linux)
    "source=${localEnv:HOME}/.snowflake,target=/host-snowflake,type=bind,consistency=cached",
    // Mount Snowflake config (Windows)
    "source=${localEnv:USERPROFILE}\\.snowflake,target=/host-snowflake,type=bind,consistency=cached",

    // Mount SSH keys (macOS / Linux)
    // SSH: Host ~/.ssh is bind-mounted here so the container transparently uses your existing keys; verify with: ssh -T git@github.com
    // NOTE: Using an absolute path (/home/vscode) instead of ${containerEnv:HOME} because
    // Docker requires the *target* path to already be a valid absolute path string at
    // invocation time. The variable substitution for ${containerEnv:HOME} happens in the
    // Dev Containers tooling layer, but in this scenario it's being passed through to
    // 'docker run' unchanged causing: "invalid mount path: '${containerEnv:HOME}/.ssh'".
    // Since the Dockerfile sets USER vscode and its home is /home/vscode, we hardcode it.
    "source=${localEnv:HOME}/.ssh,target=/home/vscode/.ssh,type=bind,consistency=cached",
    // Mount SSH keys (Windows)
    "source=${localEnv:USERPROFILE}\\.ssh,target=/home/vscode/.ssh,type=bind,consistency=cached",
  // SSH Troubleshooting (passphrase, agent reuse):
  // 1. If you keep being asked for your passphrase: start an agent inside container: eval "$(ssh-agent -s)" && ssh-add ~/.ssh/id_rsa
  // 2. If multiple keys cause auth failures: we add an IdentitiesOnly block for github.com in postCreate (see ~/.ssh/config)
  // 3. To pin a specific key: uncomment IdentityFile line in that block.
  // 4. To verify which key was used: ssh -vvvT git@github.com | grep 'Offering public key'
  // 5. If permissions warning appears for mounted keys (Windows metadata): copy the key locally and chmod 600 it.

    // Mount Git config (macOS / Linux)
    "source=${localEnv:HOME}/.gitconfig,target=/home/vscode/.gitconfig,type=bind,consistency=cached",
    // Mount Git config (Windows)
    "source=${localEnv:USERPROFILE}\\.gitconfig,target=/home/vscode/.gitconfig,type=bind,consistency=cached"
  ],

  "postCreateCommand": "/bin/bash .devcontainer/scripts/postCreate.sh",
  "postStartCommand": "/bin/bash -c 'echo \"[devcontainer] Started at $(date)\"'",
  "postAttachCommand": "/bin/bash -c 'echo \"[devcontainer] Attached. Python: $(python --version)\"'",

  // ---------------------------------------------------------------------------
  // Additional notes:
  // * Rebuild container after editing Dockerfile or features: Command Palette > Dev Containers: Rebuild.
  // * Secrets: never commit; use VS Code Secret Storage or provider-specific secret managers.
  // * Add dockerComposeFile if you need multiple services (db, cache, etc.).
  //
  // localWorkspaceFolderBasename explanation:
  // - This is another localEnv variable that gets the workspace folder name
  // - Example: if workspace is "C:\marella\personal-repo\github\container"
  // - Then ${localWorkspaceFolderBasename} = "container"
  // - Result: workspaceFolder becomes "/workspaces/container" in container
  // ---------------------------------------------------------------------------
  "workspaceFolder": "/workspaces/${localWorkspaceFolderBasename}"
}
